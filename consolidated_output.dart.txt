// Consolidated Imports
import 'package:flutter/material.dart';
import 'package:df_router/df_router.dart';
import 'dart:io';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';
import 'dart:ui' as ui;
import 'dart:collection' show LinkedHashSet;
import 'package:flutter/foundation.dart' show listEquals;
import 'package:df_pwa_utils/df_pwa_utils.dart';
import 'package:df_widgets/_common.dart';
import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

// Source: ./example/example.dart
// import 'package:flutter/material.dart';
// import 'package:df_router/df_router.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: RouteManager(
        initialRouteState: () => RouteState.parse('/home'),
        fallbackRouteState: () => RouteState.parse('/home'),
        builders: [
          RouteBuilder(
            routeState: RouteState.parse('/home'),
            builder: (context, routeState) => HomeScreen(routeState: routeState),
          ),
          RouteBuilder(
            routeState: RouteState.parse('/settings'),
            builder: (context, routeState) => SettingsScreen(routeState: routeState),
          ),
        ],
      ),
    );
  }
}

class HomeScreen extends StatelessWidget with RouteWidgetMixin {
  @override
  final RouteState<Object?>? routeState;
  const HomeScreen({super.key, this.routeState});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            final controller = RouteController.of(context);
            controller.push(RouteState.parse('/settings', animationEffect: CupertinoEffect()));
          },
          child: const Text('Go to Settings'),
        ),
      ),
    );
  }
}

class SettingsScreen extends StatelessWidget with RouteWidgetMixin {
  @override
  final RouteState<Object?>? routeState;

  const SettingsScreen({super.key, this.routeState});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            final controller = RouteController.of(context);
            controller.pushBack();
          },
          child: const Text('Go Back'),
        ),
      ),
    );
  }
}

// Source: ./dart_consolidate.dart
// import 'dart:io';

void main(List<String> arguments) async {
  final sourceDirPath = arguments.firstOrNull ?? '.';
  final sourceDir = Directory(sourceDirPath);

  if (!await sourceDir.exists()) {
    print('Directory does not exist: $sourceDirPath');
    return;
  }

  final outputFile = File('consolidated_output.dart.txt');
  final sink = outputFile.openWrite();
  final imports = <String>{}; // Set to store unique non-local imports

  // Process all files and collect imports
  await _processDirectory(sourceDir, sink, imports);

  // Write imports at the top
  sink.writeln('// Consolidated Imports');
  for (var import in imports) {
    sink.writeln(import);
  }
  sink.writeln();

  // Reprocess files to write their content with commented imports and part directives
  await _writeFileContents(sourceDir, sink);

  await sink.flush();
  await sink.close();
  print('Consolidation complete. Output written to ${outputFile.path}');
}

Future<void> _processDirectory(Directory dir, IOSink sink, Set<String> imports) async {
  await for (final entity in dir.list(recursive: true, followLinks: false)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      await _collectImports(entity, imports);
    }
  }
}

Future<void> _collectImports(File file, Set<String> imports) async {
  final lines = await file.readAsLines();
  for (var line in lines) {
    final trimmedLine = line.trim();
    if (trimmedLine.startsWith('import ')) {
      if (trimmedLine.startsWith("import 'package:") || trimmedLine.startsWith("import 'dart:")) {
        imports.add(line); // Store non-local imports
      }
    }
  }
}

Future<void> _writeFileContents(Directory dir, IOSink sink) async {
  await for (final entity in dir.list(recursive: true, followLinks: false)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      await _processFile(entity, sink);
    }
  }
}

Future<void> _processFile(File file, IOSink sink) async {
  // Write comment with original file path
  sink.writeln('// Source: ${file.path}');

  final lines = await file.readAsLines();
  for (var line in lines) {
    final trimmedLine = line.trim();
    // Comment out import statements and part directives
    if (trimmedLine.startsWith('import ') ||
        trimmedLine.startsWith('part ') ||
        trimmedLine.startsWith('part of ')) {
      sink.writeln('// $line');
    } else {
      sink.writeln(line);
    }
  }
  // Add a newline after each file's content
  sink.writeln();
}

// Source: ./.github/scripts/update_changelog.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:io';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main(List<String> args) {
  final version = args.isNotEmpty ? args[0] : '0.1.0';
  final comitMesssage = args.length > 1 ? args[1].replaceFirst('+', '') : '';
  final changelogPath = 'CHANGELOG.md';
  final file = File(changelogPath);
  if (!file.existsSync()) {
    print('$changelogPath does not exist.');
    exit(1);
  }
  var contents = file.readAsStringSync();
  contents = contents.replaceAll('# Changelog', '').trim();
  final sections = extractSections(contents);
  final versionExist = sections.where((e) => e.version == version).isNotEmpty;
  if (versionExist) {
    sections.where((e) => e.version == version).forEach((e) {
      e.addUpdate(comitMesssage);
    });
  } else {
    sections.add(
      _VersionSection(
        version: version,
        releasedAt: DateTime.now().toUtc(),
        updates: {comitMesssage},
      ),
    );
  }
  contents = '# Changelog\n\n${(sections.toList()..sort((a, b) {
      return compareVersions(b.version, a.version);
    })).map((e) => e.toString()).join('\n')}';

  file.writeAsStringSync(contents);
  print('Changelog updated with version $version.');
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Set<_VersionSection> extractSections(String contents) {
  final headerPattern = RegExp(r'## \[\d+\.\d+\.\d+(\+\d+)?\]');
  final allVersionMatches = headerPattern.allMatches(contents).toList();
  final results = <_VersionSection>{};
  for (var i = 0; i < allVersionMatches.length; i++) {
    final start = allVersionMatches[i].end;
    final end = i + 1 < allVersionMatches.length ? allVersionMatches[i + 1].start : contents.length;
    final sectionContents = contents.substring(start, end).trim();
    final lines = sectionContents.split('\n').where((line) => line.isNotEmpty).toList();
    final version =
        allVersionMatches[i].group(0)!.substring(4, allVersionMatches[i].group(0)!.length - 1);
    var releasedAt = DateTime.now().toUtc();
    final updates = <String>{};
    final old = lines
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .map((e) => e.startsWith('-') ? e.substring(1) : e)
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty);
    for (var line in old) {
      if (line.contains('Released @')) {
        releasedAt = parseReleaseDate(line);
      } else {
        updates.add(line);
      }
    }
    results.add(
      _VersionSection(
        version: version,
        releasedAt: releasedAt,
        updates: updates,
      ),
    );
  }

  return results;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class _VersionSection {
  //
  //
  //

  String version;
  DateTime releasedAt;
  Set<String> updates;

  //
  //
  //

  _VersionSection({
    required this.version,
    required this.releasedAt,
    this.updates = const {},
  });

  //
  //
  //

  void addUpdate(String update) {
    updates.add(update);
    releasedAt = DateTime.now().toUtc();
  }

  //
  //
  //

  @override
  String toString() {
    final updatesString = updates.map((update) => '- $update').join('\n');
    return '## [$version]\n\n- Released @ ${releasedAt.month}/${releasedAt.year} (UTC)\n$updatesString\n';
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

int compareVersions(String version1, String version2) {
  List<int> parseVersion(String version) {
    // Split by the '+' first to handle the build number
    final parts = version.split('+');
    final versionParts = parts[0].split('.').map(int.tryParse).map((e) => e ?? 0).toList();
    // Add the build number as the last part (if it exists)
    if (parts.length > 1) {
      versionParts.add(int.tryParse(parts[1]) ?? 0);
    }
    return versionParts;
  }

  final v1 = parseVersion(version1);
  final v2 = parseVersion(version2);
  final maxLength = v1.length > v2.length ? v1.length : v2.length;
  for (var i = 0; i < maxLength; i++) {
    final part1 = i < v1.length ? v1[i] : 0;
    final part2 = i < v2.length ? v2[i] : 0;
    if (part1 > part2) return 1;
    if (part1 < part2) return -1;
  }
  return 0;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

DateTime parseReleaseDate(String line) {
  if (line.contains('Released @')) {
    final temp = line.split('Released @').last.trim().replaceAll(' (UTC)', '');
    final parts = temp.split('/');
    if (parts.length == 2) {
      final month = int.tryParse(parts[0]) ?? 1;
      final year = int.tryParse(parts[1]) ?? DateTime.now().year;
      return DateTime.utc(year, month);
    }
  }

  return DateTime.now().toUtc();
}

// Source: ./lib/main.dart
// import 'package:flutter/material.dart';
// import 'df_router.dart';

void main() {
  runApp(const MyApp());
}

final homeRoute = RouteState.parse('/home', animationEffect: CupertinoEffect());
final settingsRoute = RouteState.parse('/settings', animationEffect: CupertinoEffect());

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      //home: // Do not use home, as it conflicts with RouteManager.
      builder: (context, child) {
        return RouteManager(
          fallbackRouteState: () => homeRoute,
          builders: [
            RouteBuilder(
              routeState: homeRoute,
              builder: (context, routeState) => HomeScreen(routeState: routeState),
            ),
            RouteBuilder(
              routeState: settingsRoute,
              builder: (context, routeState) => SettingsScreen(routeState: routeState),
            ),
          ],
        );
      },
    );
  }
}

class HomeScreen extends StatelessWidget with RouteWidgetMixin {
  @override
  final RouteState<Object?>? routeState;
  const HomeScreen({super.key, this.routeState});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            final controller = RouteController.of(context);
            controller.push(settingsRoute, animationEffect: CupertinoEffect());
          },
          child: const Text('Go to Settings'),
        ),
      ),
    );
  }
}

class SettingsScreen extends StatelessWidget with RouteWidgetMixin {
  @override
  final RouteState<Object?>? routeState;

  const SettingsScreen({super.key, this.routeState});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            final controller = RouteController.of(context);
            controller.pushBack(animationEffect: NoEffect());
          },
          child: const Text('Go Back'),
        ),
      ),
    );
  }
}

// Source: ./lib/df_router.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

/// A lightweight router designed for ease of use and efficient state management.
library;

export 'src/_src.g.dart';

// Source: ./lib/main2.dart
// import 'package:flutter/material.dart';
// import 'package:flutter/rendering.dart';

// import '/df_router.dart';

void main() {
  //debugRepaintRainbowEnabled = true;
  runApp(const MyApp());
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

final class HomeRouteState extends RouteState {
  HomeRouteState() : super.parse('/home', animationEffect: CupertinoEffect());
}

final class MessagesRouteState extends RouteState {
  MessagesRouteState() : super.parse('/messages', animationEffect: CupertinoEffect());
}

final class ChatRouteState extends RouteState<String> {
  ChatRouteState() : super.parse('/chat', animationEffect: CupertinoEffect());
}

final class MessagesRouteState1 extends RouteState {
  MessagesRouteState1()
    : super.parse(
        '/messages?key1=value1',
        queryParameters: {'key1': 'value1'},
        animationEffect: CupertinoEffect(),
      );
}

final class MessagesRouteState2 extends RouteState {
  MessagesRouteState2()
    : super.parse(
        '/messages?key1=value1',
        queryParameters: {'key2': 'value2'},
        animationEffect: CupertinoEffect(),
      );
}

final class HomeDetailRouteState extends RouteState {
  HomeDetailRouteState() : super.parse('/home_detail', animationEffect: CupertinoEffect());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      color: Colors.white,
      builder: (context, child) {
        return Material(
          child: RouteManager(
            fallbackRouteState: () => HomeRouteState(),
            // wrapper: (context, child) {
            //   return Column(
            //     crossAxisAlignment: CrossAxisAlignment.stretch,
            //     children: [
            //       // Persistent app header.
            //       Container(
            //         color: Colors.blueGrey,
            //         padding: const EdgeInsets.all(16.0),
            //         child: const Text(
            //           'df_router Example',
            //           style: TextStyle(color: Colors.white, fontSize: 24.0),
            //         ),
            //       ),
            //       // Main content area.
            //       Expanded(child: child),
            //       // Persistent app footer with navigation buttons.
            //       Container(
            //         color: Colors.indigo,
            //         padding: const EdgeInsets.all(16.0),
            //         child: Row(
            //           children: [
            //             IconButton(
            //               onPressed: () {
            //                 final controller = RouteController.of(context);
            //                 controller.push(HomeRouteState());
            //               },
            //               icon: Text(
            //                 'HOME',
            //                 style: TextStyle(
            //                   color:
            //                       RouteController.of(context).routeState.matchPath(HomeRouteState())
            //                           ? Colors.grey
            //                           : Colors.white,
            //                 ),
            //               ),
            //             ),
            //             IconButton(
            //               onPressed: () {
            //                 final controller = RouteController.of(context);
            //                 controller.push(RouteState.parse('/chat'));
            //               },
            //               icon: Text(
            //                 'CHAT',
            //                 style: TextStyle(
            //                   color:
            //                       RouteController.of(context).routeState.path == '/chat'
            //                           ? Colors.grey
            //                           : Colors.white,
            //                 ),
            //               ),
            //             ),
            //           ],
            //         ),
            //       ),
            //     ],
            //   );
            // },
            builders: [
              RouteBuilder(
                routeState: HomeRouteState(),
                builder: (context, state) {
                  return HomeScreen(key: state.key, routeState: state);
                },
              ),
              RouteBuilder(
                routeState: MessagesRouteState(),
                // Preserves the RouteState when navigating away. This means it will
                // be kept in memory and not disposed until manually disposed.
                //shouldPreserve: true,
                builder: (context, state) {
                  return MessagesScreen(routeState: state);
                },
              ),
              RouteBuilder<String>(
                routeState: ChatRouteState(),
                // Pre-builds the widget even if the RouteState is not at the top of
                // the stack. This is useful for RouteStates that are frequently
                // navigated to or that takes some time to build.
                shouldPrebuild: true,
                builder: (context, state) {
                  return ChatScreen(routeState: state);
                },
              ),
              RouteBuilder(
                routeState: HomeDetailRouteState(),
                shouldPreserve: true,
                builder: (context, state) {
                  return HomeDetailScreen(routeState: state);
                },
              ),
            ],
          ),
        );
      },
    );
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class MessagesScreen extends StatefulWidget with RouteWidgetMixin {
  @override
  final RouteState routeState;

  const MessagesScreen({super.key, required this.routeState});

  @override
  State<MessagesScreen> createState() => _MessagesScreenState();
}

class _MessagesScreenState extends State<MessagesScreen> {
  int counter = 0;

  @override
  void initState() {
    super.initState();
    debugPrint('INIT STATE MESSAGES - Params: ${widget.routeState.uri}');
  }

  @override
  void dispose() {
    debugPrint('MessagesScreen disposed - Params: ${widget.routeState.uri}');
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final controller = RouteController.of(context);
    return Container(
      color: Colors.lightGreen,
      child: Center(
        child: Column(
          spacing: 8.0,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Extra: ${widget.routeState.extra}'),
            Text(counter.toString()),
            FilledButton(
              onPressed: () => setState(() => counter++),
              child: const Text('Increment'),
            ),
            FilledButton(
              onPressed: () => controller.push(HomeRouteState()),
              child: const Text('Go to Home'),
            ),
            FilledButton(
              onPressed: () => controller.push(MessagesRouteState()),
              child: const Text('Go to Messages (No Query)'),
            ),
            FilledButton(
              onPressed: () => controller.push(MessagesRouteState1()),
              child: const Text('Go to Messages (key1=value1)'),
            ),

            FilledButton(
              onPressed:
                  () => controller.push(
                    MessagesRouteState2().copyWith(extra: 'HELLO THERE HOW ARE YOU?'),
                  ),
              child: const Text('Go to Messages (key2=value2)'),
            ),
          ],
        ),
      ),
    );
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class HomeScreen extends StatelessWidget with RouteWidgetMixin {
  @override
  final RouteState routeState;

  const HomeScreen({super.key, required this.routeState});

  @override
  Widget build(BuildContext context) {
    final controller = RouteController.of(context);
    debugPrint('INIT STATE HOME');
    return Container(
      color: Colors.yellow,
      child: Center(
        child: Column(
          spacing: 8.0,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            TextField(decoration: const InputDecoration(labelText: 'Home Screen'), readOnly: true),
            FilledButton(
              onPressed: () => controller.push(MessagesRouteState()),
              child: const Text('Go to Messages (No Query)'),
            ),
            FilledButton(
              onPressed: () => controller.push(MessagesRouteState1()),
              child: const Text('Go to Messages (key1=value1)'),
            ),
            FilledButton(
              onPressed: () => controller.push(MessagesRouteState2()),
              child: const Text('Go to Messages (key2=value2)'),
            ),
            FilledButton(
              onPressed: () => controller.push(HomeDetailRouteState()),
              child: const Text('Go to Home Detail'),
            ),
            FilledButton(
              onPressed:
                  () => controller.push(ChatRouteState().copyWith(extra: 'Hello from Home!')),
              child: const Text('Go to Chat'),
            ),
          ],
        ),
      ),
    );
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class ChatScreen extends StatefulWidget with RouteWidgetMixin<String> {
  @override
  final RouteState<String?> routeState;

  const ChatScreen({super.key, required this.routeState});

  @override
  State<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  @override
  void initState() {
    super.initState();
    debugPrint('INIT STATE CHAT - Params: ${widget.routeState}');
  }

  @override
  void dispose() {
    debugPrint('ChatScreen disposed - Params: ${widget.routeState}');
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final controller = RouteController.of(context);
    return Container(
      color: Colors.blue,
      child: Center(
        child: Column(
          spacing: 8.0,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(widget.routeState.extra.toString()),
            FilledButton(
              onPressed: () => controller.push(HomeRouteState()),
              child: const Text('Go to Home'),
            ),
            FilledButton(
              onPressed:
                  () => controller.push(ChatRouteState().copyWith(extra: 'Hello from Chat!')),
              child: const Text('Go to Chat (No ID)'),
            ),
            FilledButton(
              onPressed:
                  () => controller.push(
                    ChatRouteState().copyWith(
                      queryParameters: {'dude': '22'},
                      extra: 'Hello from Chat!',
                    ),
                  ),
              child: const Text('Go to Chat (ID=123)'),
            ),
          ],
        ),
      ),
    );
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class HomeDetailScreen extends StatelessWidget with RouteWidgetMixin {
  @override
  final RouteState? routeState;

  const HomeDetailScreen({super.key, this.routeState});

  @override
  Widget build(BuildContext context) {
    final controller = RouteController.of(context);
    debugPrint('INIT STATE HOME DETAIL');
    return Container(
      color: Colors.green,
      child: Center(
        child: Column(
          spacing: 8.0,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            FilledButton(
              onPressed: () => controller.push(HomeRouteState()),
              child: const Text('Back to Home'),
            ),
            FilledButton(
              onPressed: () => controller.push(MessagesRouteState()),
              child: const Text('Go to Messages'),
            ),
          ],
        ),
      ),
    );
  }
}

// Source: ./lib/src/route_state.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:flutter/widgets.dart';

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class RouteState<TExtra extends Object?> {
  late final Uri uri;
  final TExtra? extra;
  final bool skipCurrent;
  final AnimationEffect? animationEffect;
  final TRouteConditionFn? condition;

  Key get key => ValueKey(uri.toString());

  RouteState(
    Uri uri, {
    Map<String, String>? queryParameters,
    this.extra,
    this.skipCurrent = true,
    this.animationEffect,
    this.condition,
  }) {
    final qp = {...uri.queryParameters, ...?queryParameters};
    this.uri = uri.replace(queryParameters: qp.isNotEmpty ? qp : null);
  }

  RouteState.parse(
    String pathAndQuery, {
    Map<String, String>? queryParameters,
    this.extra,
    this.skipCurrent = true,
    this.animationEffect,
    this.condition,
  }) {
    final uri0 = Uri.parse(pathAndQuery);
    final qp = {...uri0.queryParameters, ...?queryParameters};
    this.uri = uri0.replace(queryParameters: qp.isNotEmpty ? qp : null);
  }

  RouteState<TExtra> copyWith({
    Uri? uri,
    Map<String, String>? queryParameters,
    TExtra? extra,
    bool? skipCurrent,
    AnimationEffect? animationEffect,
    TRouteConditionFn? condiiton,
  }) {
    return RouteState<TExtra>(
      uri ?? this.uri,
      queryParameters: queryParameters,
      extra: extra ?? this.extra,
      skipCurrent: skipCurrent ?? this.skipCurrent,
      animationEffect: animationEffect ?? this.animationEffect,
      condition: condition ?? this.condition,
    );
  }

  RouteState<TExtra> copyWithout({
    bool uri = true,
    bool queryParameters = true,
    bool extra = true,
    bool skipCurrent = true,
    bool animationEffect = true,
    bool condition = true,
  }) {
    return RouteState<TExtra>(
      uri ? this.uri : Uri(),
      queryParameters: queryParameters ? this.uri.queryParameters : null,
      extra: extra ? this.extra : null,
      skipCurrent: skipCurrent ? this.skipCurrent : true,
      animationEffect: animationEffect ? null : this.animationEffect,
      condition: condition ? this.condition : null,
    );
  }

  RouteState<X?> cast<X extends Object?>() => RouteState<X?>(uri, extra: extra as X?);

  bool matchPath(RouteState other) => uri.path == other.uri.path;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! RouteState) return false;
    return uri == other.uri;
  }

  String get path => uri.path;

  @override
  int get hashCode => (RouteState).hashCode ^ uri.hashCode;
}

// Source: ./lib/src/prioritized_indexed_stack/animation_effect.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:flutter/widgets.dart';

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

abstract class AnimationEffect {
  final Duration duration;
  final Curve curve;
  final List<AnimationLayerEffect> Function(BuildContext context, double value) data;

  const AnimationEffect({required this.duration, required this.curve, required this.data});
}

// Source: ./lib/src/prioritized_indexed_stack/animation_layer_effect.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:ui' as ui;

// import 'package:flutter/widgets.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

@immutable
class AnimationLayerEffect {
  final Matrix4? transform;
  final double? opacity;
  final ColorFilter? colorFilter;
  final ui.ImageFilter? imageFilter;
  final bool? ignorePointer;

  const AnimationLayerEffect({
    this.transform,
    this.opacity,
    this.colorFilter,
    this.imageFilter,
    this.ignorePointer,
  });

  bool get hasVisualEffects =>
      (opacity != null && opacity! < 1.0) || colorFilter != null || imageFilter != null;

  bool get isIdentity =>
      transform == null &&
      (opacity == null || opacity == 1.0) &&
      colorFilter == null &&
      imageFilter == null &&
      (ignorePointer == null || ignorePointer == false);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AnimationLayerEffect &&
        other.transform == transform &&
        other.opacity == opacity &&
        other.colorFilter == colorFilter &&
        other.imageFilter == imageFilter &&
        other.ignorePointer == ignorePointer;
  }

  @override
  int get hashCode => Object.hash(transform, opacity, colorFilter, imageFilter, ignorePointer);
}

// Source: ./lib/src/prioritized_indexed_stack/layer_effect_result.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class LayerEffectResult {
  final List<AnimationLayerEffect> data;
  final double value;

  const LayerEffectResult({required this.data, required this.value});
}

// Source: ./lib/src/prioritized_indexed_stack/effects.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:flutter/widgets.dart';

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class NoEffect extends AnimationEffect {
  NoEffect()
    : super(
        duration: Duration.zero,
        curve: Curves.linear,
        data: (context, value) {
          return const [AnimationLayerEffect(), AnimationLayerEffect()];
        },
      );
}

class FadeEffect extends AnimationEffect {
  FadeEffect()
    : super(
        duration: const Duration(milliseconds: 375),
        curve: Curves.easeOutSine,
        data: (context, value) {
          return [AnimationLayerEffect(opacity: value), AnimationLayerEffect(opacity: 1.0 - value)];
        },
      );
}

class QuickLeftToRightEffect extends AnimationEffect {
  QuickLeftToRightEffect()
    : super(
        duration: const Duration(milliseconds: 375),
        curve: Curves.easeInOutQuint,
        data: (context, value) {
          final size = MediaQuery.sizeOf(context);
          final width90 = size.width * 0.9;
          return [
            AnimationLayerEffect(
              transform: Matrix4.translationValues(-width90 + width90 * value, 0.0, 0.0),
            ),
            AnimationLayerEffect(
              opacity: 1.0 - value * 0.1,
              transform: Matrix4.translationValues(width90 * value * 0.5, 0.0, 0.0),
              ignorePointer: true,
            ),
          ];
        },
      );
}

class QuickRightToLeftEffect extends AnimationEffect {
  QuickRightToLeftEffect()
    : super(
        duration: const Duration(milliseconds: 375),
        curve: Curves.easeInOutQuint,
        data: (context, value) {
          final size = MediaQuery.sizeOf(context);
          final width90 = size.width * 0.9;
          return [
            AnimationLayerEffect(
              transform: Matrix4.translationValues(width90 - width90 * value, 0.0, 0.0),
            ),
            AnimationLayerEffect(
              opacity: 1.0 - value * 0.1,
              transform: Matrix4.translationValues(-width90 * value * 0.5, 0.0, 0.0),
              ignorePointer: true,
            ),
          ];
        },
      );
}

class BottomToTopEffect extends AnimationEffect {
  BottomToTopEffect()
    : super(
        duration: const Duration(milliseconds: 375),
        curve: Curves.easeInOutQuart,
        data: (context, value) {
          final size = MediaQuery.sizeOf(context);
          return [
            AnimationLayerEffect(
              transform: Matrix4.translationValues(0.0, size.height - size.height * value, 0.0),
            ),
            AnimationLayerEffect(
              opacity: 1.0 - value * 0.1,
              transform: Matrix4.translationValues(0.0, -size.height * value * 0.5, 0.0),
              ignorePointer: true,
            ),
          ];
        },
      );
}

class TopToBottomEffect extends AnimationEffect {
  TopToBottomEffect()
    : super(
        duration: const Duration(milliseconds: 375),
        curve: Curves.easeInOutQuart,
        data: (context, value) {
          final size = MediaQuery.sizeOf(context);
          return [
            AnimationLayerEffect(
              transform: Matrix4.translationValues(0.0, -size.height + size.height * value, 0.0),
            ),
            AnimationLayerEffect(
              opacity: 1.0 - value * 0.1,
              transform: Matrix4.translationValues(0.0, size.height * value * 0.5, 0.0),
              ignorePointer: true,
            ),
          ];
        },
      );
}

class BounceOutEffect extends AnimationEffect {
  BounceOutEffect()
    : super(
        duration: const Duration(milliseconds: 375),
        curve: Curves.bounceOut,
        data: (context, value) {
          final size = MediaQuery.sizeOf(context);
          return [
            AnimationLayerEffect(
              transform: Matrix4.translationValues(0.0, -size.height + size.height * value, 0.0),
            ),
            const AnimationLayerEffect(ignorePointer: true),
          ];
        },
      );
}

class CupertinoEffect extends AnimationEffect {
  CupertinoEffect()
    : super(
        duration: const Duration(milliseconds: 410),
        curve: Curves.easeInOut,
        data: (context, value) {
          final size = MediaQuery.sizeOf(context);
          return [
            AnimationLayerEffect(
              transform: Matrix4.translationValues(size.width - size.width * value, 0.0, 0.0),
            ),
            AnimationLayerEffect(
              opacity: 1.0 - value * 0.1,
              transform: Matrix4.translationValues(-size.width * value * 0.5, 0.0, 0.0),
              ignorePointer: true,
            ),
          ];
        },
      );
}

class MaterialEffect extends AnimationEffect {
  MaterialEffect()
    : super(
        duration: const Duration(milliseconds: 300),
        curve: Curves.fastOutSlowIn,
        data: (context, value) {
          final size = MediaQuery.sizeOf(context);
          return [
            AnimationLayerEffect(
              transform: Matrix4.translationValues(size.width - size.width * value, 0.0, 0.0),
            ),
            AnimationLayerEffect(
              opacity: 1.0 - value * 0.1,
              transform: Matrix4.translationValues(-size.width * value * 0.5, 0.0, 0.0),
              ignorePointer: true,
            ),
          ];
        },
      );
}

// Source: ./lib/src/prioritized_indexed_stack/animation_effect_builder.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:flutter/widgets.dart';

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class AnimationEffectBuilder extends StatefulWidget {
  final List<AnimationEffect> effects;
  final Widget Function(BuildContext context, List<LayerEffectResult> results) builder;
  final VoidCallback? onComplete;

  const AnimationEffectBuilder({
    super.key,
    required this.effects,
    required this.builder,
    this.onComplete,
  });

  @override
  State<AnimationEffectBuilder> createState() => AnimationEffectBuilderState();
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class AnimationEffectBuilderState extends State<AnimationEffectBuilder>
    with TickerProviderStateMixin {
  late List<AnimationController> controllers;
  late List<Animation<double>> animations;
  bool _hasTriggeredCompletion = false; // Track if callback has been triggered

  void setControllerValues(double value) {
    for (final controller in controllers) {
      controller.value = value;
    }
    _hasTriggeredCompletion = false; // Reset completion state
  }

  void forwardControllers() {
    for (final controller in controllers) {
      controller.forward();
    }
    _hasTriggeredCompletion = false; // Reset completion state
  }

  void reverseControllers() {
    for (final controller in controllers) {
      controller.reverse();
    }
    _hasTriggeredCompletion = false; // Reset completion state
  }

  @override
  void initState() {
    super.initState();
    _initializeAnimations();
  }

  void _initializeAnimations() {
    controllers =
        widget.effects.map((config) {
          final controller = AnimationController(
            vsync: this,
            duration: config.duration,
            value: 1.0,
          );
          // Add status listener to track completion
          controller.addStatusListener(_handleAnimationStatus);
          return controller;
        }).toList();
    animations =
        widget.effects.asMap().entries.map((entry) {
          final index = entry.key;
          final config = entry.value;
          return CurvedAnimation(parent: controllers[index], curve: config.curve);
        }).toList();
  }

  void _handleAnimationStatus(AnimationStatus status) {
    // Check if all controllers are completed
    if (status == AnimationStatus.completed && !_hasTriggeredCompletion) {
      final allCompleted = controllers.every(
        (controller) => controller.status == AnimationStatus.completed,
      );
      if (allCompleted) {
        widget.onComplete?.call();
        _hasTriggeredCompletion = true; // Prevent multiple triggers
      }
    }
  }

  @override
  void didUpdateWidget(AnimationEffectBuilder oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.effects.length != oldWidget.effects.length) {
      for (var controller in controllers) {
        controller.removeStatusListener(_handleAnimationStatus);
        controller.dispose();
      }
      _initializeAnimations();
    } else {
      for (var i = 0; i < widget.effects.length; i++) {
        if (widget.effects[i].duration != oldWidget.effects[i].duration) {
          controllers[i].duration = widget.effects[i].duration;
        }
        if (widget.effects[i].curve != oldWidget.effects[i].curve) {
          animations[i] = CurvedAnimation(parent: controllers[i], curve: widget.effects[i].curve);
        }
      }
    }
    _hasTriggeredCompletion = false; // Reset completion state on widget update
  }

  @override
  void dispose() {
    for (final controller in controllers) {
      controller.removeStatusListener(_handleAnimationStatus);
      controller.dispose();
    }
    super.dispose();
  }

  void reset() {
    for (final controller in controllers) {
      controller.value = 0.0;
    }
    _hasTriggeredCompletion = false; // Reset completion state
  }

  void forward() {
    for (final controller in controllers) {
      controller.forward();
    }
    _hasTriggeredCompletion = false; // Reset completion state
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: Listenable.merge(animations),
      builder: (context, child) {
        final results =
            animations.asMap().entries.map((entry) {
              final index = entry.key;
              final animation = entry.value;
              final data = widget.effects[index].data(context, animation.value);
              final value = animation.value;
              return LayerEffectResult(data: data, value: value);
            }).toList();
        return widget.builder(context, results);
      },
    );
  }
}

// Source: ./lib/src/prioritized_indexed_stack/prioritized_indexed_stack.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: omit_local_variable_types

// import 'package:flutter/widgets.dart';
// import 'package:flutter/rendering.dart';
// import 'dart:collection' show LinkedHashSet;
// import 'package:flutter/foundation.dart' show listEquals;

// import '../_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class PrioritizedIndexedStack extends StatelessWidget {
  const PrioritizedIndexedStack({
    super.key,
    this.alignment = AlignmentDirectional.topStart,
    this.textDirection,
    this.clipBehavior = Clip.hardEdge,
    this.sizing = StackFit.loose,
    this.indices = const <int>[],
    this.children = const <Widget>[],
    this.layerEffects,
  });

  final AlignmentGeometry alignment;
  final TextDirection? textDirection;
  final Clip clipBehavior;
  final StackFit sizing;
  final List<int> indices;
  final List<Widget> children;
  final List<AnimationLayerEffect>? layerEffects;

  @override
  Widget build(BuildContext context) {
    final effectiveIndices = indices.map((index) => index == -1 ? null : index).toList();

    final childOriginalIndexToStackingOrder = <int, int>{};
    if (children.isNotEmpty) {
      for (var order = 0; order < effectiveIndices.length; order++) {
        final childIdx = effectiveIndices[order];
        if (childIdx != null && childIdx >= 0 && childIdx < children.length) {
          if (!childOriginalIndexToStackingOrder.containsKey(childIdx)) {
            childOriginalIndexToStackingOrder[childIdx] = order;
          }
        }
      }
    }

    final wrappedChildren = List<Widget>.generate(children.length, (int i) {
      final stackingOrder = childOriginalIndexToStackingOrder[i];
      final isActive = stackingOrder != null;
      var childWidget = children[i];
      return Visibility.maintain(visible: isActive, child: childWidget);
    });

    return _RawPrioritizedIndexedStack(
      alignment: alignment,
      textDirection: textDirection,
      clipBehavior: clipBehavior,
      sizing: sizing,
      indices: effectiveIndices,
      layerEffects: layerEffects,
      children: wrappedChildren,
    );
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class _RawPrioritizedIndexedStack extends Stack {
  const _RawPrioritizedIndexedStack({
    super.alignment,
    super.textDirection,
    super.clipBehavior,
    required StackFit sizing,
    required this.indices,
    this.layerEffects,
    super.children,
  }) : super(fit: sizing);

  final List<int?> indices;
  final List<AnimationLayerEffect>? layerEffects;

  @override
  RenderPrioritizedIndexedStack createRenderObject(BuildContext context) {
    assert(
      _debugCheckHasDirectionality(
        context,
        alignment: alignment,
        textDirection: textDirection,
        why: () => 'to resolve $alignment for this PrioritizedIndexedStack widget',
      ),
    );
    return RenderPrioritizedIndexedStack(
      indices: indices,
      layerEffects: layerEffects,
      alignment: alignment,
      textDirection: textDirection ?? Directionality.maybeOf(context),
      clipBehavior: clipBehavior,
      fit: fit,
    );
  }

  @override
  void updateRenderObject(BuildContext context, RenderPrioritizedIndexedStack renderObject) {
    assert(
      _debugCheckHasDirectionality(
        context,
        alignment: alignment,
        textDirection: textDirection,
        why: () => 'to resolve $alignment for this PrioritizedIndexedStack widget',
      ),
    );
    renderObject
      ..indices = indices
      ..layerEffects = layerEffects
      ..alignment = alignment
      ..textDirection = textDirection ?? Directionality.maybeOf(context)
      ..clipBehavior = clipBehavior
      ..fit = fit;
  }

  @override
  MultiChildRenderObjectElement createElement() {
    return _PrioritizedIndexedStackElement(this);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class RenderPrioritizedIndexedStack extends RenderStack {
  RenderPrioritizedIndexedStack({
    required List<int?> indices,
    List<AnimationLayerEffect>? layerEffects,
    super.children,
    super.alignment,
    super.textDirection,
    super.fit,
    super.clipBehavior,
  }) : _indices = indices,
       _layerEffects = layerEffects;

  List<int?> _indices;
  List<int?> get indices => _indices;
  set indices(List<int?> value) {
    if (listEquals(_indices, value)) return;
    _indices = value;
    markNeedsPaint();
    markNeedsSemanticsUpdate();
  }

  List<AnimationLayerEffect>? _layerEffects;
  List<AnimationLayerEffect>? get layerEffects => _layerEffects;
  set layerEffects(List<AnimationLayerEffect>? value) {
    if (listEquals(_layerEffects, value)) return;
    _layerEffects = value;
    markNeedsPaint();
  }

  RenderBox? _getChildRenderBox(int? targetIndex) {
    if (targetIndex == null || targetIndex < 0 || firstChild == null) return null;
    var currentChild = firstChild;
    var i = 0;
    while (currentChild != null) {
      if (i == targetIndex) return currentChild;
      final childParentData = currentChild.parentData! as StackParentData;
      currentChild = childParentData.nextSibling;
      i++;
    }
    return null;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    if (firstChild == null || _indices.isEmpty) {
      return;
    }

    // Iterate in reverse paint order (bottom-most visible child first, then layers on top)
    for (var stackingOrder = _indices.length - 1; stackingOrder >= 0; stackingOrder--) {
      final childOriginalIndex = _indices[stackingOrder];
      if (childOriginalIndex == null) continue;

      final RenderBox? childToPaint = _getChildRenderBox(childOriginalIndex);
      if (childToPaint == null) continue;

      final StackParentData childParentData = childToPaint.parentData! as StackParentData;
      final AnimationLayerEffect? effectData =
          (_layerEffects != null && stackingOrder < _layerEffects!.length)
              ? _layerEffects![stackingOrder]
              : null;

      // This is the child's position as determined by the Stack layout, relative to the Stack's origin.
      final Offset childStackLayoutOffset = childParentData.offset;
      // This is the absolute offset where painting related to this child will start.
      final Offset absoluteChildPaintOrigin = offset + childStackLayoutOffset;

      // --- Layer for visual effects (opacity, colorFilter, imageFilter) ---
      bool needsSaveLayerForVisualEffects =
          (effectData?.opacity != null && effectData!.opacity! < 1.0) ||
          effectData?.colorFilter != null ||
          effectData?.imageFilter != null;
      Paint? visualEffectsPaint;

      if (needsSaveLayerForVisualEffects) {
        visualEffectsPaint = Paint();
        if (effectData!.opacity != null) {
          // Ensure opacity is applied correctly.
          // Multiplying alpha by 255 for the Paint's color.
          visualEffectsPaint.color = Color.fromRGBO(0, 0, 0, effectData.opacity!);
        }
        if (effectData.colorFilter != null) {
          visualEffectsPaint.colorFilter = effectData.colorFilter;
        }
        if (effectData.imageFilter != null) {
          visualEffectsPaint.imageFilter = effectData.imageFilter;
        }
        // The saveLayer is established at the child's absolute position.
        // Subsequent drawing operations within this layer are relative to this position.
        context.canvas.saveLayer(absoluteChildPaintOrigin & childToPaint.size, visualEffectsPaint);
      }

      // --- Apply transform using pushTransform ---
      final Matrix4? animationTransform = effectData?.transform;

      // The offset at which the child should be painted by the painter callback of pushTransform.
      // If we used saveLayer, we're already "at" the child's position, so paint at Offset.zero within the layer.
      // Otherwise, paint at the child's layout offset relative to the current context (which includes the stack's `offset`).
      final Offset offsetForPainter =
          needsSaveLayerForVisualEffects ? Offset.zero : absoluteChildPaintOrigin;

      if (animationTransform != null && !animationTransform.isIdentity()) {
        context.pushTransform(
          childToPaint
              .needsCompositing, // Crucial: hints to Flutter to use a TransformLayer if needed
          offsetForPainter, // The offset passed to the painter callback
          animationTransform, // The transformation matrix
          (PaintingContext paintingContext, Offset painterOffset) {
            // painterOffset will be the same as offsetForPainter.
            // The canvas is already transformed by animationTransform.
            // We paint the child at painterOffset within this transformed coordinate system.
            paintingContext.paintChild(childToPaint, painterOffset);
          },
        );
      } else {
        // No animationTransform or it's an identity matrix
        // Paint the child directly at the calculated offset.
        // If inside a saveLayer, this offset is Offset.zero (relative to layer's origin).
        // Otherwise, it's absoluteChildPaintOrigin.
        context.paintChild(childToPaint, offsetForPainter);
      }

      if (needsSaveLayerForVisualEffects) {
        context.canvas.restore(); // Restore from saveLayer
      }
    }
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    if (firstChild == null || _indices.isEmpty) {
      return false;
    }

    for (var stackingOrder = 0; stackingOrder < _indices.length; stackingOrder++) {
      final childOriginalIndex = _indices[stackingOrder];
      if (childOriginalIndex == null) continue;

      final childToTest = _getChildRenderBox(childOriginalIndex);
      if (childToTest == null) continue;

      final AnimationLayerEffect? effectData = _layerEffects?[stackingOrder];

      // Check for ignorePointer or fully transparent
      if (effectData?.ignorePointer == true ||
          (effectData?.opacity != null && effectData!.opacity! <= 0.0)) {
        continue; // Skip hit testing for this child
      }

      final childParentData = childToTest.parentData! as StackParentData;
      final Offset childStackOffset = childParentData.offset; // Child's offset within the Stack
      final Matrix4? transform = effectData?.transform;

      bool hitted;
      if (transform != null) {
        hitted = result.addWithPaintTransform(
          transform: transform,

          position: position + childStackOffset,
          hitTest: (BoxHitTestResult hitTestResult, Offset transformedLocalPosition) {
            return childToTest.hitTest(hitTestResult, position: transformedLocalPosition);
          },
        );
      } else {
        hitted = result.addWithPaintOffset(
          offset: childStackOffset,
          position: position,
          hitTest: (BoxHitTestResult hitTestResult, Offset localPosition) {
            return childToTest.hitTest(hitTestResult, position: localPosition);
          },
        );
      }

      if (hitted) {
        return true;
      }
    }
    return false;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<List<int?>>('indices (effective)', _indices));
    properties.add(
      DiagnosticsProperty<List<AnimationLayerEffect>>(
        'layerEffects',
        _layerEffects,
        defaultValue: null,
      ),
    );
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class _PrioritizedIndexedStackElement extends MultiChildRenderObjectElement {
  _PrioritizedIndexedStackElement(_RawPrioritizedIndexedStack super.widget);
  @override
  _RawPrioritizedIndexedStack get widget => super.widget as _RawPrioritizedIndexedStack;
  // ... (debugVisitOnstageChildren remains the same) ...
  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    if (children.isEmpty) {
      return;
    }
    final effectiveIndices = widget.indices;
    if (effectiveIndices.isEmpty) {
      return;
    }
    // ignore: prefer_collection_literals
    final visitedChildIndices = LinkedHashSet<int>();
    for (final targetIndex in effectiveIndices) {
      if (targetIndex != null && targetIndex >= 0 && targetIndex < children.length) {
        if (visitedChildIndices.add(targetIndex)) {
          visitor(children.elementAt(targetIndex));
        }
      }
    }
  }
}

bool _debugCheckHasDirectionality(
  BuildContext context, {
  required AlignmentGeometry alignment,
  required TextDirection? textDirection,
  required String Function() why,
}) {
  if (textDirection == null && alignment is AlignmentDirectional) {
    assert(Directionality.maybeOf(context) != null, why());
  }
  return true;
}

// Source: ./lib/src/route_manager.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:flutter/widgets.dart';

// import '_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class RouteManager extends StatelessWidget {
  final RouteState Function()? initialRouteState;
  final RouteState Function() fallbackRouteState;
  final RouteState<Enum> Function()? errorState;
  final void Function(RouteController controller)? onControllerCreated;
  final List<RouteBuilder> builders;

  final TRouteWrapperFn? wrapper;

  const RouteManager({
    super.key,
    this.initialRouteState,
    required this.fallbackRouteState,
    this.errorState,
    this.onControllerCreated,
    required this.builders,
    this.wrapper,
  });

  @override
  Widget build(BuildContext context) {
    final controller = RouteController(
      initialRouteState: initialRouteState,
      fallbackRouteState: fallbackRouteState,
      errorRouteState: errorState,
      builders: builders,
    );

    onControllerCreated?.call(controller);
    return RouteControllerProvider(
      controller: controller,
      child: ValueListenableBuilder(
        valueListenable: controller.pRouteState,
        builder: (context, value, snapshot) {
          final child = ClipRect(child: controller.buildScreen(context, value));
          return wrapper?.call(context, child) ?? child;
        },
      ),
    );
  }
}

typedef TRouteWrapperFn = Widget Function(BuildContext context, Widget child);

// Source: ./lib/src/route_builder.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:flutter/widgets.dart';

// import '_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class RouteBuilder<TExtra extends Object?> {
  final RouteState<TExtra> routeState;
  final bool shouldPreserve;
  final bool shouldPrebuild;
  late final TRouteWidgetBuilder builder;
  final TRouteConditionFn? condition;

  RouteBuilder({
    required this.routeState,
    this.shouldPreserve = false,
    this.shouldPrebuild = false,
    required TRouteWidgetBuilder<TExtra> builder,
    this.condition,
  }) {
    this.builder = (context, state) => builder(context, state.cast<TExtra>());
  }

  RouteBuilder<TExtra> copyWith({
    RouteState<TExtra>? routeState,
    bool? shouldPreserve,
    bool? shouldPrebuild,
    TRouteWidgetBuilder<TExtra>? builder,
    TRouteConditionFn? condition,
  }) {
    return RouteBuilder<TExtra>(
      routeState: routeState ?? this.routeState,
      shouldPreserve: shouldPreserve ?? this.shouldPreserve,
      shouldPrebuild: shouldPrebuild ?? this.shouldPrebuild,
      builder: builder ?? this.builder as TRouteWidgetBuilder<TExtra>,
      condition: condition ?? this.condition,
    );
  }

  RouteBuilder<TExtra> copyWithout({
    bool shouldPreserve = true,
    bool shouldPrebuild = true,
    bool condition = true,
  }) {
    return RouteBuilder<TExtra>(
      routeState: this.routeState,
      shouldPreserve: shouldPreserve ? false : this.shouldPreserve,
      shouldPrebuild: shouldPrebuild ? false : this.shouldPrebuild,
      builder: (context, state) => this.builder(context, state) as RouteWidgetMixin<TExtra>,
      condition: condition ? null : this.condition,
    );
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef TRouteConditionFn = bool Function();

typedef TRouteWidgetBuilder<TExtra extends Object?> =
    RouteWidgetMixin<TExtra> Function(BuildContext context, RouteState<TExtra?> routeState);

// Source: ./lib/src/route_controller.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: invalid_use_of_protected_member, invalid_use_of_visible_for_testing_member

// import 'package:df_pwa_utils/df_pwa_utils.dart';
// import 'package:df_widgets/_common.dart';

// import '_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class RouteController {
  //
  //
  //

  // TODO: Convert to Pod once that flashing error is fixed.
  final _pRouteState = ValueNotifier(RouteState.parse('/'));
  ValueListenable<RouteState> get pRouteState => _pRouteState;
  RouteState get routeState => _pRouteState.value;

  final _widgetCache = <RouteState, Widget>{};

  late final List<RouteBuilder> builders;

  late RouteState _prevRouteState = _pRouteState.value;
  final RouteState Function()? errorRouteState;
  final RouteState Function() fallbackRouteState;
  RouteState? _requestedRouteState;

  AnimationEffect nextEffect = NoEffect();

  //
  //
  //

  RouteController({
    RouteState Function()? initialRouteState,
    this.errorRouteState,
    required this.fallbackRouteState,
    required this.builders,
  }) {
    platformNavigator.addStateCallback(pushUri);
    // Set all the builder output to SizedBox.shrink.
    resetState();
    _requestedRouteState = getNavigatorRouteState();
    final routeState = initialRouteState?.call() ?? _requestedRouteState ?? fallbackRouteState();
    push(routeState);
  }

  //
  //
  //

  RouteState getNavigatorOrFallbackRouteState() => _requestedRouteState ?? fallbackRouteState();

  //
  //
  //

  RouteState? getNavigatorRouteState() {
    final url = platformNavigator.getCurrentUrl();
    if (url == null) {
      return null;
    }
    return _getBuilderByPath(url)?.routeState.copyWith(queryParameters: url.queryParameters);
  }

  //
  //
  //

  void addStatesToCache(Iterable<RouteState> routeStates) {
    for (final routeState in routeStates) {
      final builder = _getBuilderByPath(routeState.uri);
      if (builder == null) continue;
      if (_widgetCache[routeState] is Builder) continue;
      _widgetCache[routeState] = Builder(
        key: routeState.key,
        builder: (context) {
          return builder.builder(context, routeState);
        },
      );

      _pRouteState.notifyListeners();
    }
  }

  //
  //
  //

  void removeStatesFromCache(Iterable<RouteState> routeStates) {
    for (final routeState in routeStates) {
      final builder = _getBuilderByPath(routeState.uri);
      if (builder == null) continue;
      if (_widgetCache[routeState] is SizedBox) continue;
      _widgetCache[routeState] = SizedBox.shrink(key: routeState.key);
      _pRouteState.notifyListeners();
    }
  }

  //
  //
  //

  void clearCache() {
    for (final builder in builders) {
      _widgetCache[builder.routeState] = SizedBox.shrink(key: builder.routeState.key);
    }
  }

  //
  //
  //

  void resetState() {
    clearCache();
    final routeStates = builders
        .where((builder) => builder.shouldPrebuild)
        .map((e) => e.routeState);
    addStatesToCache(routeStates);
  }

  //
  //
  //

  void _maybeRemoveStaleRoute(RouteState routeState) {
    final builder = _getBuilderByPath(routeState.uri);
    if (builder == null) return;
    if (!builder.shouldPreserve) {
      _widgetCache[routeState] = SizedBox.shrink(key: routeState.key);
    }
  }

  //
  //
  //

  void pushUri(Uri uri) => push(RouteState(uri));

  //
  //
  //

  void pushBack({RouteState? fallback, AnimationEffect? animationEffect}) {
    if (_prevRouteState.path == '/') {
      push(fallback ?? fallbackRouteState(), animationEffect: animationEffect);
    } else {
      push(_prevRouteState, animationEffect: animationEffect);
    }
  }

  //
  //
  //

  void push<TExtra extends Object?>(
    RouteState<TExtra> routeState, {
    RouteState? errorFallback,
    RouteState? fallback,
    AnimationEffect? animationEffect,
  }) {
    nextEffect = animationEffect ?? routeState.animationEffect ?? NoEffect();
    print(nextEffect);
    final uri = routeState.uri;
    final skipCurrent = routeState.skipCurrent;
    if (skipCurrent && _pRouteState.value.uri == uri) {
      return;
    }
    if (_checkExtraTypeMismatch<TExtra>(uri) == false) {
      debugPrint('[RouteController.push] Error!');
      final errorFallback1 = errorFallback ?? errorRouteState?.call();
      if (errorFallback1 != null) {
        push(errorFallback1);
      }
      return;
    }
    if (!pathExists(uri)) {
      debugPrint('[RouteController.push] Error!');
      final errorFallback1 = errorFallback ?? errorRouteState?.call();
      if (errorFallback1 != null) {
        push(errorFallback1);
      }
      return;
    }
    final condition = routeState.condition;
    final a = condition == null || condition();
    if (!a) {
      debugPrint('[RouteController.push] Condition not met!');
      push(fallback ?? fallbackRouteState());
      return;
    }
    final condition2 = _getBuilderByPath(uri)?.condition;
    final b = condition2 == null || condition2.call();
    if (!b) {
      debugPrint('[RouteController.push] Condition not met!');
      push(fallback ?? fallbackRouteState());
      return;
    }
    platformNavigator.pushState(uri);

    _prevRouteState = _pRouteState.value;

    // Remove the previous route state from the cache if it is stale.

    _pRouteState.value = routeState;
    addStatesToCache([routeState]);

    _globalKey.currentState?.setControllerValues(0.0);
    _globalKey.currentState?.forward();
  }

  //
  //
  //

  bool pathExists(Uri path) {
    return builders.any((e) => e.routeState.path == path.path);
  }

  //
  //
  //

  bool _checkExtraTypeMismatch<TExtra extends Object?>(Uri path) {
    return builders.any((e) {
      return e.routeState.path == path.path && e is RouteBuilder<TExtra>;
    });
  }

  //
  //
  //

  RouteBuilder? _getBuilderByPath(Uri path) {
    return builders.where((routeState) => routeState.routeState.path == path.path).firstOrNull;
  }

  //
  //
  //

  final _globalKey = GlobalKey<AnimationEffectBuilderState>();

  Widget buildScreen(BuildContext context, RouteState routeState) {
    return AnimationEffectBuilder(
      key: _globalKey,
      effects: [nextEffect],
      onComplete: () {
        _maybeRemoveStaleRoute(_prevRouteState);
      },
      builder: (context, results) {
        final layerEffects = results.map((e) => e.data).toList()[0];
        return PrioritizedIndexedStack(
          indices: [
            _widgetCache.keys.toList().indexOf(routeState),
            _widgetCache.keys.toList().indexOf(_prevRouteState),
          ],
          layerEffects: layerEffects,
          children: _widgetCache.values.toList(),
        );
      },
    );
  }

  //
  //
  //

  void dispose() {
    platformNavigator.removeStateCallback(pushUri);
    _pRouteState.dispose();
    _widgetCache.clear();
  }

  //
  //
  //

  static RouteController of(BuildContext context) {
    final provider = context.dependOnInheritedWidgetOfExactType<RouteControllerProvider>();
    if (provider == null) {
      throw FlutterError('No RouteStateControllerProvider found in context');
    }
    return provider.controller;
  }
}

// Source: ./lib/src/route_contoller_provider.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:flutter/widgets.dart';

// import '_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class RouteControllerProvider extends InheritedWidget {
  final RouteController controller;

  const RouteControllerProvider({super.key, required this.controller, required super.child});

  @override
  bool updateShouldNotify(RouteControllerProvider oldWidget) => controller != oldWidget.controller;
}

// Source: ./lib/src/route_widget_mixin.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:flutter/widgets.dart';

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

mixin RouteWidgetMixin<TExtra extends Object?> on Widget {
  RouteState<TExtra?>? get routeState;
}

// Source: ./lib/src/_src.g.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_indexes
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

export './route_state.dart';
export './prioritized_indexed_stack/animation_effect.dart';
export './prioritized_indexed_stack/animation_layer_effect.dart';
export './prioritized_indexed_stack/layer_effect_result.dart';
export './prioritized_indexed_stack/effects.dart';
export './prioritized_indexed_stack/animation_effect_builder.dart';
export './prioritized_indexed_stack/prioritized_indexed_stack.dart';
export './route_manager.dart';
export './route_builder.dart';
export './route_controller.dart';
export './route_contoller_provider.dart';
export './route_widget_mixin.dart';
export './route_widget_builder.dart';

// Source: ./lib/src/route_widget_builder.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:flutter/widgets.dart';

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class RouteWidgetBuilder<TExtra extends Object?> extends StatelessWidget
    with RouteWidgetMixin<TExtra> {
  @override
  final RouteState<TExtra?>? routeState;
  final Widget Function(BuildContext context, RouteState<TExtra?>? routeState) builder;

  const RouteWidgetBuilder({super.key, this.routeState, required this.builder});

  @override
  Widget build(BuildContext context) {
    return builder(context, routeState);
  }
}

// Source: ./.dart_tool/dartpad/web_plugin_registrant.dart
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

// import 'package:shared_preferences_web/shared_preferences_web.dart';
// import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  SharedPreferencesPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}

